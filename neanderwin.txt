NEANDER-X - Resumo operacional
-------------------------------

O Neander-X é um simulador da máquina Neander, definida no livro
do Raul F. Weber (UFRGS), Fundamentos de Arquitetura de Computadores,
Ed. Sagra Luzzatto.  A máquina original foi estendida para incluir 
algumas instruções adicionais, como a carga de dados imediatos
no acumulador e operações de entrada e saida de dados. Em nosso
simulador estão mapeados apenas dois dispositivos: um teclado e um visor.

1) Listagem geral das instruções

Todas as instruções são de 8 bits, sendo que algumas possuem um
operando de 8 bits adicional.  Em ambos os casos o primeiro byte 
contém o código da operação nos 4 bits de mais alta ordem. Nas
instruções com um operando, este ocupa o segundo byte.  

Nota: Os 4 bits de mais baixa ordem do primeiro byte são reservados
para futuras expansões.

'NOP' código 0        
        O comando NOP é usado apenas para gastar tempo.

'STA ender' código 1
        O comando STA guarda o acumulador na posição de memória
        indicada pelo operando ender.

'LDA ender' código 2
        O comando LDA atribui ao acumulador o conteúdo da posição de
        memória indicada pelo operando ender.

'ADD ender' código 3
        O comando ADD soma ao acumulador o conteúdo de uma posição de
        memória indicada pelo operando ender.

'SUB ender' código 4
        O comando ADD soma ao acumulador o conteúdo de uma posição de
        memória indicada pelo operando ender.

'OR ender'  código 5
        O comando OR realiza um "ou" lógico entre o acumulador e o
        conteúdo de uma posição de memória indicada pelo operando
        ender.

'AND ender' código 6
        O comando AND realiza um "e" lógico entre o acumulador e o
        conteúdo de uma posição de memória indicada pelo operando
        ender.

'NOT ender' código 7
        O comando NOT inverte os bits do acumulador ender.

'JMP edner' código 8
        O comando JMP (jump) desvia a execução do programa para
        o endereço indicado pelo operando ender.

'JN ender'  código 9
        O comando JN (jump if negative) desvia a execução do programa
        para o endereço indicado pelo operando ender, apenas quando a
        última operação realizada produziu um valor com o bit 7 ligado
       (negativo).

'JZ ender'  código 10
        O comando JZ (jump if zero) desvia a execução do programa
        para o endereço indicado pelo operando ender, apenas quando a
        última operação realizada produziu um valor zero.

'JNZ ender'  código 11
        O comando JNZ (jump if not zero) desvia a execução do programa
        para o endereço indicado pelo operando ender, apenas quando a
        última operação realizada produziu um valor diferente de
        zero.

'IN ender'  código 12
        O comando IN (input) traz para o acumulador o valor lido
        num dispositivo externo indicado pelo operando ender. 
        Em nosso simulador os dispositivos são: chaves (endereço 0)
        e o status de "dado disponível" das chaves (endereço 1).

'OUT ender' código 13
        O comando OUT (output) descarrega o conteúdo do acumulador em
        um dispositivo externo indicado pelo operando ender.  Em nosso
        simulador o único dispositivo disponível é um visor
        (endereço 0).

'LDI imed' código 14
        O comando LDI (load immediate) carrega no acumulador o valor
        dado pelo operando imed.

'HLT' código 15
        O comando HLT (halt) para a máquina.

Modos de Endereçamento:

- imediato
         O segundo byte da instrução é o operando.
         A única instrução que usa este modo de endereçamento é a LDI.
- direto
         O segundo byte da instrução é o endereço de memória do
	 operando.
- indireto
         O segundo byte da instrução contém o endereço de memória onde
         está o endereço do operando (ou seja, o segundo byte da
         instrução é o endereço do ponteiro para o operando).
	 Para indicar que um operando é indireto, deve-se precedê-lo
         pela letra "@" (arrôba)

2) Códigos de Condição

A seguir são apresentados os códigos de condição do Neander-X, 
ou seja, flags que indicam o resultado da última operação realizada
pela UAL.

N – (negativo): sinal do resultado
	1 – resultado é negativo
	0 – resultado não é negativo

Z – (zero): indica resultado igual a zero
	1 – resultado é igual a zero
	0 – resultado diferente de zero

As instruções lógicas e aritméticas (ADD, NOT, AND, OR)
e a instrução de transferência LDA afetam os códigos de condição
N e Z de acordo com o resultado produzido. As demais instruções
(STA, JMP, JN, JZ, JNZ, IN, OUT, LDI, NOP e HLT)
não alteram os códigos de condição.

3) Formato geral 

Uma linha pode conter alguns dos seguintes elementos: um
rótulo, um operador ou uma pseudo-instrução, um operando
opcional e comentários. São permitidas linhas vazias.

a) Comentários no programa

Os comentários são começados por ponto e vírgula, e podem
também ocorrer no final das linhas com instruções ou
pseudo-instruções.

b) Rótulos

Um rótulo é um nome dado à próxima posição de memória.
Os rótulos são construídos segundo as regras a seguir:

- Usam letras alfabéticas ou numéricas ou $ ou _ mas
não espaços.
- A primeira letra não pode ser numérica.
- Não existe distinção entre maiúsculas e minúsculas (ou
seja ’a’ é o mesmo que ’A’).
- O rótulo deve ser seguido por dois pontos. A única
exceção é rótulo utilizado na pseudo-instrução EQU.

4) Pseudo Instruções

Pseudo instruções são orientações que o programador passa
para o montador, com o intuito de organizar e posicionar o
código e variáveis na memória do simulador.

i} ORG ender – ORG (origin) indica ao montador que
a próxima instrução ou dado será colocado na posição
ender de memória. Por exemplo:
	ORG 0
	...
	Instruções
	...
	ORG 100
	...
	Dados
	...
	END 0

ii) var EQU imed – EQU (equate) atribui um nome
(rótulo) a um determinado valor. Entre muitos usos
possíveis, esse comando pode ser usado para especificar
variáveis que são posicionadas em um endereço específico
de memória. Pode ser utilizado também para
definir constantes, por exemplo:

	INC EQU 2
	MAX EQU 99
	MIN EQU 0

iii) END ender – END indica que o programa fonte acabou.
O operando ender é usado para pré-carregar o PC
com o endereço inicial do programa, ou seja, quando o
programa é carregado na memória para execução, esse
valor é carregado no PC para indicar o endereço inicial
de execução.

iv} DS imed – DS (define storage) reserva um número
de bytes na memória definido pelo operando imed, sem
nenhum valor inicial.

	A: DS 1
	VETOR: DS 10

v)  DB imed – DB (define bytes) carrega esta posição de
memória com o valor definido pelo operando imed.

	A: 	DB 20
	VETOR: 	DB 1
	       	DB 2
		DB 3
		DB 4

5) Exemplos de representação de números

O número 48 teria as seguintes representações possíveis:

- Decimal: 48
- Hexadecimal: 30h
- Binário: 00110000b

Obs: Números hexadecimais maiores que 7Fh devem ser
precedidos por um zero, p. ex. 0F3h.

Os números negativos não tem forma de representação possível
no montador, embora resultados negativos das operações sejam
representados em complemento a dois no simulador, logo, os números
maiores que 127 (7Fh) podem ser considerados negativos.
No capítulo seguinte apresentamos uma série de exemplos de
programação com a linguagem de montagem do Neander-X.